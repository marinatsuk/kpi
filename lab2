;------------------------------------------------------------------------------
;ЛР  № 2. Прямий доступ до вілеопам'яті у Real Adress Mode
;-----------------------------------------------------------------------------
;Архітектура комп'ютера
;ВУЗ: НТУУ КПІ
;Факультет: ФІОТ
;Курс: 1
;Група: ІТ-03
;-----------------------------------------------------------------------------
;Автор: Бублик, Дудченко, Цуканова
;Дата: 02.03.21
;----------------I.ЗАГОЛОВОК ПРОГРАМИ-----------------------
IDEAL         ; Директива - тип Асемблера tasm
MODEL SMALL   ; Директива - тип моделі пам'яті
STACK 256     ; Директива - розмір стеку в байтах
;-----------------II.МАКРОСИ----------------------------------------
;макрос для ініціалізації
MACRO M_Init		; Початок макросу 
mov	ax, @data		; ax <- @data
mov	ds, ax			; ds <- ax
mov	es, ax			; es <- ax
ENDM M_Init		; Кінець макросу

;--------------------III.ПОЧАТОК СЕГМЕНТУ ДАНИХ----------------------
DATASEG

exCode db 0
; одна лінія прямокутника
rect_line db  48h, 2Eh, 65h, 2Eh, 6Ch, 2Eh, 6Ch, 2Eh, 6Fh, 2Eh, 20h, 2Eh, 66h, 2Eh, 72h, 2Eh, 6Fh, 2Eh, 6Dh, 2Eh
          db  20h, 2Eh, 74h, 2Eh, 65h, 2Eh, 61h, 2Eh, 6Dh, 2Eh, 20h, 2Eh, 38h, 2Eh, 21h, 2Eh, 21h, 2Eh, 21h, 2Eh
	  
; тут 2 - салатовий колір фону, Е - жовтий колів надписів, 
; символи з таблиці ASCII складають надпис "Hello from team 8!!!"
; всього 20 елементів
        	      
rect_line_length = $-rect_line ; Довжина масиву 

;----------------------VI. ПОЧАТОК СЕГМЕНТУ КОДУ-----------------
CODESEG
Start:	
	M_Init      ;використовуємо макрос

	mov dx, 1008 ; початок виводу прямокутника, координата верхнього лівого кута визначається за формулою 160*y+2*x
		     ; де у - кількість рядків зверху, х - кількість символів зліва
		     ; оскільки 50,50 занадто велика, обираємо інші координати y=6, x=24
	mov cx, 10   ; лічильник ітерацій циклу
; отже виводимо прямокутник 20х10 за координатами y = 6, x = 24
;---------------------------------------------------------------------------
loopStart:		

;використовуємо команду movsb з префіксом rep в регістрі cx
;де movsb - записати в комірку з адресою ES:DI байт з комірки з адресою DS:SI
;де rep - повторити наступну строкову операцію

	mov bx, cx        	 ; зберігаємо значення лічильника cx в іншому регістрі bx
	mov ax, 0B800h    	 ; сегментна адреса в відеопам'яті
	mov es, ax        	 ; es <- ax
	
; налаштування SI, DI, CX для movsb
	mov di, dx               ; di <- початок виводу на екран
	mov si, offset rect_line ; si <- наш рядок
	mov cx, rect_line_length ; cx <- число байтів на пересилання
	cld                      ; команда cld очищує прапор направлення DF
	rep movsb                ; саме пересилання
	mov cx, bx               ; після виконання rep movsb регістр cx вільний, отже передаємо в нього значення регістру bx
	add dx, 160              ; зміщення наступної лінії
LOOP loopStart                   ; використовуємо команду LOOP, яка повторює блок коду, поки лічильник не стане рівним 0
;----------------------------------------------------------------------------
Exit:
     mov ah,04ch     ; функція DOS завершення програми
     mov al,[exCode] ;отримання коду виходу
     int 21h         ; виклик функції DOS 4ch
END Start



