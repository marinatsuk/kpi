TITLE ЛР_6
;------------------------------------------------------------------------------
; Дисципліна: Архітектура комп'ютера
; НТУУ "КПІ"
; Факультет: ФІОТ
; Курс: 1
; Група: ІТ-03
;------------------------------------------------------------------------------
; Автор: Бублик, Дудченко, Цуканова
; Дата: 28.04.2021
;------------------------------------------------------------------------------
IDEAL

;------------------------------------------------------------------------------
MACRO M_Init  ; Ініціалізація DS та ES
mov ax, @data ; ax <- @data
mov ds, ax    ; ds <- ax
mov es, ax    ; es <- ax
ENDM

MODEL small
STACK 256

DATASEG
msg db "Team 8 : Dudchenko, Tsukanova, Bublik $"

bak_int58h_offset DW ? ; Ефективна адреса функції - стандартного обробника апаратного переривання СОМ1
bak_int58h_seg DW ?    ; Адреса початку сегменту  функції апаратного переривання СОМ1

CODESEG

PROC main
M_Init                 ; Макрос ініціалізації

; Етап 1. Отримання ефективної адреси і зміщення переривання --------------------

; Отримання ефективної адреси і зміщення стандартного обробника переривання СОМ1 для його заміни
; Це виконуються з використанням функції getIntVector
mov di, 58h            ; Вхідний параметр функції getIntVector
call getIntVector      ; Виклик
                       ; Вихідні аргументи процедури (bx - еф. адреса, es сег. адреса)
                       ; Збереження у змінних для повернення ст. обробника переривання 
mov [bak_int58h_offset], bx ; Зберігаємо значення еф. адреси у змінній
mov [bak_int58h_seg], es    ; Зберігаємо значення адреси сегменту у змінній

; Етап 2. Збереження стандартного обробника переривань СОМ 2 за іншим вектором

; Використаємо функцію setIntVector
; DI Вхідний аргумент - номер вектора, куди переносимо.
; DX Вхідний аргумент - еф. адреса процедури яку переносимо
; ES Вхідний аргумент - адреса сегмента процедури яку переносимо.

mov di, 58h 				; Вхідний аргумент setIntVector – новий вектор DI для СОМ1 
mov dx, bx 					; Нове зміщення процедури DX (еф. адреса)
                            ; Новий сегмент ES для процедури той же
call setIntVector           ; Виклик. Переносимо стандартну функцію обробки СОМ2 на вектор 58h

; Етап 3. Визначення нового обробника переривання з дод. функціоналом на вектор 58h

; Підготовка аргументів

mov di, 58h                 ; DI Вхідний аргумент - номер старого вектора пер.СОМ
mov dx, OFFSET int58h       ; DX Вхідний аргумент - еф. адреса нової проц.
mov ax, SEG int58h          
mov es, ax                  ; Завантажуємо таки ES. Оскільки mov ES, SEG int58hES не дозволено
call setIntVector           ; Виклик 

int 58h 					; виклик переривання

; Етап 4. Повернення переривання у вихідний стан
mov di, 58h
mov dx, [bak_int58h_offset]
mov ax, [bak_int58h_seg]
mov es, ax
call setIntVector

xor al, al					; встановлюємо al на нуль
mov ah, 04Ch                ; Номер вектору переривання DOS на виході
int 21h                     ; Виклик переривання
ENDP main                   ; Закінчення функції main

;--------------------------------------------------------------------------
PROC getIntVector
; Призначення: Отримання логічної адреси процедури (функції) обробки переривання за
; номером вектора переривання
; Вхід:	 DI <- номер вектора переривання
; Вихід: BX <- Ефективна адреса процедури (функції) обробки переривання
;	     ES <- Адреса сегмента процедури (функції) обробки переривання

;--------------------------------------------------------------------------
; Збереження стану регістрів
push ax
push di

xor ax, ax						; Очищуємо AX
mov es, ax				 		; Перехід на початок сегменту 0000h
shl di, 2 						; Логічний зсув вліво. Множимо DI на 4 (зв’язок номера переривання і адреси) 
mov bx, [es:[di]] 				; Ефективну адресу функції обробника в BX
mov ax, [es:[di + 2]] 			; Адресу сегменту функції обробника в АХ
mov es, ax 						; Адресу сегменту функції обробника таки до ES
; Відновлення задіяних регістрів
pop di
pop ax
ret 							; Повертаємось з процедури (функції)
ENDP getIntVector

;--------------------------------------------------------------------------
PROC setIntVector
; Призначення: Установка на номер вектора нової функції обробника.
; Функціонально: до пам’яті що відповідає вектору заносимо ефективну адресу і адресу
; сегменту нового обробника переривань
; На вхід:	DI - номер переривання де буде нова процедура
;	DX - ефективна адреса нового обробника
;	ES - адреса сегмента нового обробника
; На вихід: ---

;--------------------------------------------------------------------------
Cli 							; Заборона апаратних переривань

; Збереження регістрів
push ax
push di
push ds

xor ax, ax 						; Очищуємо AX
mov ds, ax 						; Переходимо до адреси 0000h
shl di, 2 						; Логічний зсув вліво. Множимо DI на 4 (зв’язок номера переривання і адреси)
mov [ds:[di]], dx 				; Записуємо ефективну адресу до першої половини вектора
mov [ds:[di + 2]], es 			; Записуємо адресу сегменту в другу половину вектору

; Відновлення регістрів
pop ds
pop di
pop ax
sti 							; Дозвіл переривань
ret 							; Повертаємось з процедури (функції)
ENDP setIntVector

;--------------------------------------------------------------------------
PROC int58h
; Призначення: Нова процедура (функція) обробника переривання для COM.
; На вхід:	---
; На вихід:	---
;--------------------------------------------------------------------------
 mov ah, 09h				    ; Надрукувати повідомлення
 mov dx, offset msg
 int 21h
; Код закінчення апаратного переривання
 mov al, 20h				    ; Вихід в операційну систему
 out 20h, al
 iret 						    ; Вихід з функції обробника
ENDP int58h
END main                        ; Кінець коду
