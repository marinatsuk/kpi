TITLE ЛР_8 
;------------------------------------------------------------------------------
;ЛР  №8
;------------------------------------------------------------------------------
; Архітектура комп'ютера
; Завдання:Псевдо-графічний інтерфейс
; ВУЗ: КНУУ "КПІ"
; Факультет:    ФІОТ
; Курс:                1
; Група:       ІТ-03
;------------------------------------------------------------------------------
; Автор:        Цуканова Дудченко Бублик
; Дата:         19.05.2021
;---------------------------------
IDEAL			; Директива - тип Асемблера tasm 
MODEL small		; Директива - тип моделі пам’яті 
STACK 2048		; Директива - розмір стеку 
;---------------------  Сегмент даних ----------------------------------------
DATASEG

menu_color EQU 0070h      ;0070h - grey
current_color EQU 0010h   ;0010h - blue
output_color EQU 0030h    ;0030h - light blue

symbols_size EQU 23       ;кількість елементів в рядку меню
top_row  EQU  5           ;верхній рядок меню
bottom_row EQU 9          ;нижній рядок меню
left_col EQU 30           ;колонка зліва
output_row EQU 15         ;рядок виводу 
menu_items EQU 3          ;кількість елементів меню
current_row DB 1

menu DB  '#######################'
     DB  '| ---View creators--- |'
     DB  '| -------Sound------- |'
     DB  '| ----Calculation---  |'
     DB  '#######################' 

help_out db ' Arrows up/down, ESC - escape, Enter - choose  '
outpur_size=$-help_out
madeBy db ' Team 8: Tsukanova, Dudchenko, Bublik          '
equation db ' ((-2-3)+1)/2*3)=                               '
equation_size EQU 17  ;кількість елементів у рядку з формулою
;значення змінних
a1 EQU -2
a2 EQU 3
a3 EQU 1
a4 EQU 2
a5 EQU 3

frequency EQU 2705
duration EQU 1500

CODESEG
;--------------------Створюємо макроси--------------------------------
MACRO M_push         ;макрос для запам'ятовування значень регістрів
push ax
push bx
push cx
push dx
push bp
push si
push di
ENDM M_push    
;--------------------

MACRO M_pop           ;макрос для повернення значень регістрів
pop di
pop si
pop bp
pop dx
pop cx
pop bx
pop ax
ENDM M_pop     
;--------------------

MACRO M_drawOut      ;макрос для виведення меню
mov dh, output_row   ;початок виведення зверху  
mov dl, 0            ;початок виведення зліва  
mov ax, 1300h        ;функція відображення символів 
mov bx, output_color ;колір виводу
mov cx, outpur_size  ;кількість символів для відображення
int 10h              ;виклик переривання BIOS
ENDM M_drawOut

;-------------------------------------------------
Start:
mov ax, @data	    ; ax <- @data
mov ds, ax		    ; ds <- ax
mov es, ax		    ; es <- ax
mov al,1
out 42h, al       ;ініціалізація таймера

call clean        ;Виклик очистки екрану
call drawmenu     ;Виклик відображення меню
call drawCurrent  ;Виклик виведення теперішнього вибраного рядка
lea bp, [help_out];Виведення помічного тексту
M_drawOut
call inputChecker ;Виклик зчитування з клавіатури та обробок

;--------------------Створюємо процедури---------------
;Ввід : немає
;Вивід: немає
;--------------Очищення екрану--------------------------
PROC clean
M_push               ;виклик макросу запам'ятовування значень регістрів
mov ax, 0600h        ;функція монотонного залиття екрану
mov bh, 30h          ;колір фону
mov cx, 0            ;відступ зліва
mov dx,184Fh         ;dh, dl - кількість зафарбованих рядків, колонок
int 10h              ;переривання BIOS

M_pop                ;виклик макросу повернення значень регістрів
ret
ENDP clean

;---------------- Виведення меню -----------------------
;Ввід : немає
;Вивід: немає
;-------------------------------------------------------
PROC drawmenu   
M_push                ;виклик макросу запам'ятовування значень регістрів

mov dh, top_row       ;початок виведення зверху  
mov dl, left_col      ;початок виведення зліва  
mov ax, 1300h         ;функція відображення символів 
mov bx, menu_color    ;колір меню
mov cx, symbols_size  ;кількість символів для відображення
xor si,si             ;вибраний рядок

main_loop_1:          ;цикл для виведення меню
lea bp, [menu+si]     ;вибір рядка для відображення
int 10h               ;виклик переривання BIOS
inc dh                ;збільшення dh
add si, symbols_size  ;збільшення si
cmp dh, bottom_row+1  ;перевірка на кінець меню
jne main_loop_1       ;перевірка на кінець меню

M_pop                 ;виклик макросу повернення значень регістрів
ret
ENDP drawmenu
;--------------------

;Ввід : немає
;Вивід: немає
PROC drawCurrent
M_push                  ;виклик макросу запам'ятовування значень регістрів

call drawmenu           ;виклик процерури виведення меню
mov dh, [current_row]   ;початок виведення зверху
add dh, top_row         
mov dl, left_col+1      ;початок виведення зліва  
mov cx, symbols_size-2  ;кількість символів для відображення
mov al, symbols_size    
mov bl, [current_row]   ;визначення, який пункт буде обрано
mul bl                  
mov si, ax              
mov ax, 1300h           ;функція відображення символів 
mov bx, current_color   ;колір вибраного пункту
lea bp, [menu+si+1]     ;вибір рядка для відображення
int 10h                 ;виклик переривання BIOS

M_pop                   ;виклик макросу повернення значень регістрів
ret
ENDP drawCurrent

;--------------------Зчитування з клавіатури-------------------------------------
;Ввід : немає
;Вивід: немає
;----------------------------------------------------------------------
PROC inputChecker
M_push                  ;виклик макросу запам'ятовування значень регістрів

input_loop_1:
mov ah, 10h             ;функція зчитування з клавіатури
int 16h
cmp ah, 50h             ;стрілка вверх
je arrow_up
cmp ah, 48h             ;стрілка вниз
je arrow_down
cmp al, 0Dh             ;Enter
je enter_
cmp al, 1Bh             ;ESC
je escape
jmp input_loop_1        ;повторення циклу
;
arrow_down:
mov al, [current_row]   ;вибір рядка
cmp al, 1               ;перевірка на максимум
je input_loop_1         ;вихід, якщо максимум
dec al
mov [current_row], al   ;Зміна теперішнього рядка
call drawCurrent        ;Виведення на екран теперішнього рядка
jmp input_loop_1

arrow_up:
mov al, [current_row]   ;вибір рядка
cmp al, menu_items      ;перевірка на максимум
je input_loop_1         ;вихід, якщо максимум
inc al
mov [current_row], al   ;Зміна теперішнього рядка
call drawCurrent        ;Виведення на екран теперішнього рядка
jmp input_loop_1

enter_:
call procChooser        ;виклик процедури виклику процедур
jmp input_loop_1

escape:                 ;Вихід з программи
mov ah, 4Ch
int 21h
M_pop                   ;виклик макросу повернення значень регістрів
ret
ENDP inputChecker

;--------------------Вибір потрібної процедури--------------------------
;Ввід : немає
;Вивід: немає
;-----------------------------------------------------------------------
PROC procChooser        ;процедура виклику потрібної процедури
M_push                  ;виклик макросу запам'ятовування значень регістрів

mov al, [current_row]   ;Перевірка вибранного рядка
cmp al, 1
je item_1
cmp al, 2
je item_2
cmp al, 3
je item_3

item_1:                 ;Перший пункт меню - виведення прізвищ учасників команди
lea bp, [madeBy]   
M_drawOut 
jmp proc_chooser_end

item_2:                 ;Другий пункт меню - виведення звуку
call sound
jmp proc_chooser_end

item_3:                 ;Третій пункт меню - виведення розрахувань
call calc
jmp proc_chooser_end

proc_chooser_end:

M_pop                 ;виклик макросу повернення значень регістрів
ret
ENDP procChooser

;--------------------------Процедура виведення звуку ---------------
; Призначення: програвання звуку
; Вхід:
; frequency <- частота звуку
; duration <- тривалість звуку
; Вихід: звук
; ---------------------------------------------------------------------------------
PROC sound
M_push           ;виклик макросу запам'ятовування значень регістрів

in al, 61h       ;одержуємо стан динаміка
push ax          ;зберігаємо стан динаміка
or al, 00000011B ;зміна стану на включений динамік
out 61h, al      ;занесення стану
mov ax, frequency;виставляємо частоту
out 42h, al      ;вмикаємо таймер, що буде подавати імпульси на динамік за заданою частотою
call waiting     ;виклик процедури очікування
pop ax           ;повернення стану динаміка
and al, 11111100B;зміна стану на виключений динамік
out 61h, al      ;занесення стану

M_pop            ;виклик макросу повернення значень регістрів
ret
ENDP sound

;--------------------- Процедура очікування ----------------------------------------
;Ввід : немає
;Вивід: немає
;-----------------------------------------------------------------------------------
PROC waiting ;процедура очікування, простий перебіг за 2 циклами
M_push
;
mov cx, duration
loop1:             	  
  PUSH cx	             
  MOV  cx,  duration
  loop2:
     LOOP loop2
  POP  cx
  LOOP loop1
;
M_pop
ret
ENDP waiting  ;кінець процедури очікування

;---------------------Процедура обчислення --------------------------------------------
;Ввід : немає
;Вивід: немає
;-------------------------------------------------------------------------------------
PROC calc       ;процедура обчислення виразу, та його виводу на екран

		mov ax, 0
    xor dx, dx		; dx <- 0
    mov ax, a1		; ax <- a1
    mov bx, a2		; bx <- a2
    sub ax, bx		; ax <- a1-a2


    mov bx, a3 		; bx <- a3
    add ax, bx 		; ax <- ax + bx	
    mov bx, a4		; bx <- a4
    idiv bx			  ; ax <- ax/bx	
    mov bx, a5		; bx <-a5
    imul bx		    ; ax <- ax*bx

    cmp al, 0
		jns number_printer
		;якщо результат від'ємний
		minus_printer:
			neg ax
			mov ah, '-'
		; Вивід результату у консоль
		number_printer:
		add al, 30h
		; Виводимо число у консоль
		mov [equation+equation_size], ah    ;занесення значення для виводу
		mov [equation+equation_size+1], al  ;занесення значення для виводу
		lea bp, [equation]
    M_drawOut
	  ret				;повертаємось з процедури

ENDP calc   ;кінець процедури
;---------------------

mov ah, 4ch
int 21h
end Start
